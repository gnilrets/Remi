<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: README
  
    &mdash; Documentation by YARD 0.8.7.4
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.README.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'><h1>Remi - Ruby Extract Modify Integrate</h1>

<p><strong>Purpose:</strong> Remi is a Ruby-based ETL suite that is built to provide
an expressive data transformation language and facilitate the design
and implementation of business logic.</p>

<p><strong>Vision:</strong> The vision of a functioning Remi solution includes (See
also the <a href="/doc/vision_a_story.md">fluffier long version</a>)</p>

<ul>
<li><p><em>Core transformations</em> - The heart of any ETL solution is the
ability to define, sort, merge, and aggregate data.  Remi seeks to
provide a framework to make these core tasks simple and natural.</p></li>
<li><p><em>Business rule driven development support</em> - Borrowing from
principles of Test Driven Development (TDD), Remi will be built to
support Business Rule Driven Development (BRDD).  BRDD captures the
idea that the definition of business rules, data discovery, and ETL
coding all need to be developed in concert and continually refined.
<em>All</em> transformation logic encoded in the ETL need to
accessible to business users.</p></li>
<li><p><em>Versioned data modeling support</em> - In order to have an agile data
warehouse, we need to be able to quickly build and rebuild the data
model that is populated using ETL.  Versioning the data model is
necessary to enable sane management of the data model changes.  Remi
will very likely borrow heavily (if not completely) from ActiveRecord
and Rails, which already provide solid data model versioning.</p></li>
<li><p><em>Data flows</em> - Efficiently moving data from multiple source systems
to multiple target systems can involve a large number intermediate
steps and complex dependencies.  Remi will provide a data flow logic
to define and assist in the proper execution of these dependencies
for larger projects.  It will conform to the BRDD principle that the
transformations that are performed on the data will still be exposed
and consumable to business users.</p></li>
<li><p><em>Fun</em> - Finally, Remi is a toolset that makes developing ETL
solutions more fun!</p></li>
</ul>

<p><strong>Status:</strong> Definitely not ready for production, but ripe for play.
Right now the focus is mostly on refining the basic ETL structure in
how Remi will define, sort, merge, and aggregate data.  Once this
basic functionality has been established and demonstrated to have
performance on par with other solutions for production work, BRDD
development can begin. See the <a href="Roadmap">/doc/roadmap.md</a> for a rough
sketch of plans.</p>

<p>I intend to follow <a href="http://semver.org/">semantic versioning</a>
principles.  Of course, while we&#39;re still on major version zero, no
attempt will be made to maintain backward compatibility.</p>

<h2>Installation</h2>

<p>So, this will eventually be packaged as a gem with a tool to set up
standard Remi projects, but for now we&#39;re only testing, so just</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_bundle'>bundle</span> <span class='id identifier rubyid_install'>install</span>
</code></pre>

<p>and go!</p>

<h2>Usage Overview</h2>

<p>Data in Remi is stored in <em>Datasets</em>.  A dataset is an ordered
collection of data <em>records</em>.  Each record is a collection of variable
name/value pairs.  Typically, datasets occupy physical space on a
drive, although they might eventually be abstracted to enable support
for in-memory or in-database datasets that use a common API.  Datasets
are contained in a <em>Data Library</em> that may be a directory in a file
system, a database/schema on a database server, or just some
partitioned space in memory.  A <em>Datastep</em> is an operation on a
dataset that can involve reading, writing, modifying variable values,
sorting, merging, interleaving, or aggregating.</p>

<h3>Libraries and datasets</h3>

<p>Presently, Remi only supports directory-based data libraries.  A data library
is created by instantiating the <strong>Datalib</strong> class</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_mylib'>mylib</span> <span class='op'>=</span> <span class='const'>Datalib</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='symbol'>:directory</span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span> <span class='symbol'>:dirname</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>/tmp</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
</code></pre>

<p>Referencing a dataset that is contained in a library looks just like accessing
a method</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_dataset_instance'>dataset_instance</span> <span class='op'>=</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata'>mydata</span>
</code></pre>

<p>Calling <code>mylib.mydata</code> returns an instance of the dataset class with
the name <code>mydata</code>.</p>

<h6>Proposed</h6>

<p>I originally chose this syntax because it mimicked
SAS, which I was most familiar with.  However, I&#39;m thinking about
refactoring this to something that may be more natural to Ruby
programmers and better capture the idea that a dataset is contained in
a library.  So in the future, datasets may be accessed more like this</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_dataset_instance'>dataset_instance</span> <span class='op'>=</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='lbracket'>[</span><span class='symbol'>:mydata</span><span class='rbracket'>]</span>
</code></pre>

<p>The rest of the examples will follow the existing method and this
README will be updated when the code is updated.</p>

<h3>Creating data</h3>

<p>The simplest currently functioning &quot;Hello World!&quot; example for Remi would be</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata'>mydata</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds'>ds</span><span class='op'>|</span>
  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_ds'>ds</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:myvariable</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='symbol'>:myvariable</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_write_row'>write_row</span>
<span class='kw'>end</span>
</code></pre>

<p>This code creates a dataset called <code>mydata</code> in the <code>mylib</code> library
(defined in the previous section).  The dataset contains a single
variable called <code>myvariable</code> with the string value &quot;Hello World!&quot;.
Remi does not enforce variable types.  We could just have easily set
<code>myvariable</code> to the number <code>18</code> or even assigned it to be an array or
hash or any other valid Ruby object (of course, when it comes to using
the dataset to write a CSV file for export or populate a database,
assigning a variable to an array might not make much sense).  Variable
types should be enforced through the business rules.</p>

<p>Variables may also be associated with any amount of metadata,
represented as a hash.  You can use the metadata any way you like.
For example, you could use to trigger upcasing flagged variables.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata'>mydata</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds'>ds</span><span class='op'>|</span>
  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_ds'>ds</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:var1</span><span class='comma'>,</span> <span class='symbol'>:upcase</span> <span class='op'>=&gt;</span> <span class='kw'>true</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:var2</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:var3</span><span class='comma'>,</span> <span class='symbol'>:upcase</span> <span class='op'>=&gt;</span> <span class='kw'>true</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='symbol'>:var1</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='symbol'>:var2</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>to the</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='symbol'>:var3</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>world!</span><span class='tstring_end'>&quot;</span></span>

  <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_vars'>vars</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='id identifier rubyid_v'>v</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='id identifier rubyid_v'>v</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_upcase'>upcase</span> <span class='kw'>if</span> <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_vars'>vars</span><span class='lbracket'>[</span><span class='id identifier rubyid_v'>v</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='symbol'>:upcase</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_write_row'>write_row</span>
<span class='kw'>end</span>
</code></pre>

<h6>Proposed</h6>

<p>Currently the only way to define variables in a block.  It would be nice to allow
for single line definitions for simple datasteps.  For example
Definitely going to do this</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata'>mydata</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds'>ds</span><span class='op'>|</span>
  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='symbol'>:var1</span><span class='comma'>,</span> <span class='symbol'>:var2</span>
  <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='symbol'>:var1</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='symbol'>:var2</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>World!</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_write_row'>write_row</span>
<span class='kw'>end</span>
</code></pre>

<p>Also, we might want to consider allowing implicit variable creation
(although this can increase the likelihood of typos causing a
problem).  Additionally, we could support an <em>implicit</em> <code>write_row</code>
step at the end of the block, unless an explicit call to <code>write_row</code>
is made.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata'>mydata</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds'>ds</span><span class='op'>|</span>
  <span class='id identifier rubyid_ds'>ds</span><span class='lbracket'>[</span><span class='symbol'>:myvariable</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
</code></pre>

<h3>Viewing data</h3>

<p>Any dataset can be browsed by calling a data view.  This uses the
Google Chart Tools to visual data (via
<a href="https://github.com/winston/google_visualr">GoogleVisualr</a>).  It
launches a browser window that shows the data.  Currently it&#39;s pretty
rudimentary and data that is larger than about 1,000 records may take
a long time to load.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Dataview</span><span class='period'>.</span><span class='id identifier rubyid_view'>view</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata'>mydata</span>
</code></pre>

<h6>Proposed</h6>

<p>It would be great if we could support some kind of paging to the data view so
we wouldn&#39;t have to require the user to make sure their data is &lt;1,000 records.
It might also be nice if we could somehow make the webpage sample random records
from a given dataset.</p>

<h3>Reading data</h3>

<p>Suppose I already have a data set called <code>have</code> that exists in library
<code>mylib</code> and has a variable called <code>:active</code> that stores either &quot;Y&quot; or
&quot;N&quot;.  If we wanted to read that dataset and transform it so that we
have all the same variables in <code>have</code> plus a new variable called
<code>:active_print</code> that maps &quot;Y&quot; and &quot;N&quot; to &quot;Yes&quot; and &quot;No&quot;, we could do this</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_active_map'>active_map</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Y</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Yes</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>N</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>No</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
  <span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_want'>want</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_want'>want</span><span class='op'>|</span>
    <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_want'>want</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
      <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_have'>have</span>
      <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:active_print</span>
    <span class='kw'>end</span>

    <span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_read'>read</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_have'>have</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_have'>have</span><span class='op'>|</span>
      <span class='id identifier rubyid_want'>want</span><span class='lbracket'>[</span><span class='symbol'>:active_print</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_active_map'>active_map</span><span class='lbracket'>[</span><span class='id identifier rubyid_have'>have</span><span class='lbracket'>[</span><span class='symbol'>:active</span><span class='rbracket'>]</span><span class='rbracket'>]</span>
      <span class='id identifier rubyid_want'>want</span><span class='lbracket'>[</span><span class='symbol'>:active_print</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Undefined</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_want'>want</span><span class='lbracket'>[</span><span class='symbol'>:active_print</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_want'>want</span><span class='period'>.</span><span class='id identifier rubyid_write_row'>write_row</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
</code></pre>

<p>In the variable definition block we&#39;ve used the <code>import</code> method to inherit
all variables from the <code>mylib.have</code> dataset.  The <code>import</code> method accepts
<code>keep</code> and <code>drop</code> arguments to flexibly specify the variables to be imported.
Use <code>keep</code> to include only the specified variables</p>

<pre class="code ruby"><code class="ruby">  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_want'>want</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_have'>have</span><span class='comma'>,</span> <span class='symbol'>:keep</span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='symbol'>:last_name</span><span class='comma'>,</span> <span class='symbol'>:salary</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>
</code></pre>

<p>and use <code>drop</code> to exclude all variables except those specified</p>

<pre class="code ruby"><code class="ruby">  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_want'>want</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_have'>have</span><span class='comma'>,</span> <span class='symbol'>:drop</span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='symbol'>:first_name</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>
</code></pre>

<p>If <code>mylib.have</code> had the variables
<code>[:last_name, :first_name, :salary]</code>, then the import statements above would both
give the same result.</p>

<h3>Importing from CSV</h3>

<p>Remi provides an interface that makes it easy to load data from CSV
files into Remi datasets.  There are currently two ways to import: one
is with trusted headers headers and the other is with custom headers.
When using trusted headers, dataset variables are created that have
the same name as the header column headers in the CSV file.  This is
convenient for quick-and-dirty work.  But in production environments
we may not want to trust the names in the headers, and instead rely on
column position.  Below demonstrates both methods.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_csv_file_full_path'>csv_file_full_path</span> <span class='op'>=</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='const'>ENV</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>HOME</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='comma'>,</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mydata.csv</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

<span class='comment'># Trusted headers
</span><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_from_csv'>from_csv</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds'>ds</span><span class='op'>|</span>
  <span class='const'>CSV</span><span class='period'>.</span><span class='id identifier rubyid_datastep'>datastep</span> <span class='id identifier rubyid_csv_file_full_path'>csv_file_full_path</span><span class='comma'>,</span> <span class='label'>header_to_vars:</span> <span class='id identifier rubyid_ds'>ds</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_row'>row</span><span class='op'>|</span>
    <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_read_row_from_csv'>read_row_from_csv</span><span class='lparen'>(</span><span class='id identifier rubyid_row'>row</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_write_row'>write_row</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># Custom headers - any variables with :csv_col metadata are read from the CSV file
</span><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_from_csv_custom'>from_csv_custom</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds'>ds</span><span class='op'>|</span>
  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_ds'>ds</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:first_name</span><span class='comma'>,</span> <span class='symbol'>:csv_col</span> <span class='op'>=&gt;</span> <span class='int'>0</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:last_name</span><span class='comma'>,</span> <span class='symbol'>:csv_col</span> <span class='op'>=&gt;</span> <span class='int'>1</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:salary</span><span class='comma'>,</span> <span class='symbol'>:csv_col</span> <span class='op'>=&gt;</span> <span class='int'>7</span>
  <span class='kw'>end</span>

  <span class='const'>CSV</span><span class='period'>.</span><span class='id identifier rubyid_datastep'>datastep</span> <span class='id identifier rubyid_csv_file_full_path'>csv_file_full_path</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_row'>row</span><span class='op'>|</span>
    <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_read_row_from_csv'>read_row_from_csv</span><span class='lparen'>(</span><span class='id identifier rubyid_row'>row</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_ds'>ds</span><span class='period'>.</span><span class='id identifier rubyid_write_row'>write_row</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h6>Proposed</h6>

<p>It might be nice to add keep/drop functionality to trusted headers so that we
can optionally retain only specified variables.</p>

<h3>Interleaving and stacking</h3>

<p>Assuming that two or more datasets are all sorted by the same
variables, those datasets can be interleaved resulting in a dataset
that is also sorted by the same variables</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata'>mydata</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds_out'>ds_out</span><span class='op'>|</span>
  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_ds'>ds</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_in1'>ds_in1</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_in2'>ds_in2</span>
  <span class='kw'>end</span>

  <span class='const'>Dataset</span><span class='period'>.</span><span class='id identifier rubyid_interleave'>interleave</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_in1'>ds_in1</span><span class='comma'>,</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_in2'>ds_in2</span><span class='comma'>,</span> <span class='label'>by:</span> <span class='lbracket'>[</span><span class='symbol'>:var1</span><span class='comma'>,</span> <span class='symbol'>:var2</span><span class='rbracket'>]</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds_interleave'>ds_interleave</span><span class='op'>|</span>
    <span class='id identifier rubyid_ds_out'>ds_out</span><span class='period'>.</span><span class='id identifier rubyid_read_row_from'>read_row_from</span> <span class='id identifier rubyid_ds_interleave'>ds_interleave</span>
    <span class='id identifier rubyid_ds_out'>ds_out</span><span class='period'>.</span><span class='id identifier rubyid_write_row'>write_row</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Alternatively, if the <code>by</code> option is omitted, the resulting dataset just contains
datasets <code>ds_in1</code> and <code>ds_in2</code> stacked in the order given.</p>

<h6>Proposed</h6>

<p>Perhaps it would be more natural to put these operations in <code>Datastep.read</code> and it
would be obvious from context whether it&#39;s a straight read, interleave, or stack.</p>

<h3>Sorting</h3>

<p>Sorting is pretty straightforward: just specify input and output datasets and
an ordered list of variables that should be used to sort:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_sort'>sort</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata_unsorted'>mydata_unsorted</span><span class='comma'>,</span> <span class='label'>out:</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_mydata_sorted'>mydata_sorted</span><span class='comma'>,</span> <span class='label'>by:</span> <span class='lbracket'>[</span><span class='symbol'>:last_name</span><span class='comma'>,</span><span class='symbol'>:first_name</span><span class='rbracket'>]</span>
</code></pre>

<p>By default, Remi uses an external sort algorithm for any datasets
larger than 100,000 rows.  For these large datasets, Remi will split the dataset into
100,000 row chunks, sort each chunk in memory, and then use the interleave method
to combine all of the sorted chunks into the final dataset.  The interleave
method is currently very inefficient and needs some significant improvement, so
sorting large datasets is pretty sluggish right now.</p>

<h6>Proposed</h6>

<p>Need to implement <strong>Ascending</strong> and <strong>Descending</strong> options</p>

<h3>By-groups</h3>

<p>Passing a <code>by</code> argument to <code>Datastep.read</code> provides access to methods
that indicate whether a particular row is first or last in a group.
By-groups always assume that the input data is sorted by the variables
indicated in the by-group.  This can be useful for performing complex
aggregation or in-group logic.  The simple example below shows how
by-groups can be used to count the number of records that are observed
for each value of <code>:var1</code></p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Assumes mylib.have is sorted by :var1
</span><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_grouped'>grouped</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds_out'>ds_out</span><span class='op'>|</span>
  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_ds_out'>ds_out</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_have'>have</span><span class='comma'>,</span> <span class='symbol'>:keep</span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='symbol'>:var1</span><span class='rbracket'>]</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='symbol'>:var1_count</span>
  <span class='kw'>end</span>

  <span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_read'>read</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_have'>have</span><span class='comma'>,</span> <span class='label'>by:</span> <span class='lbracket'>[</span><span class='symbol'>:var1</span><span class='rbracket'>]</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds_in'>ds_in</span><span class='op'>|</span>
    <span class='comment'># Initialize the counter when encountering the first record in a group
</span>    <span class='id identifier rubyid_ds_out'>ds_out</span><span class='lbracket'>[</span><span class='symbol'>:var1_count</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='int'>0</span> <span class='kw'>if</span> <span class='id identifier rubyid_ds_in'>ds_in</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='lparen'>(</span><span class='symbol'>:var1</span><span class='rparen'>)</span>
    <span class='comment'># Increment the counter
</span>    <span class='id identifier rubyid_ds_out'>ds_out</span><span class='lbracket'>[</span><span class='symbol'>:var1_count</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_ds_out'>ds_out</span><span class='lbracket'>[</span><span class='symbol'>:var1_count</span><span class='rbracket'>]</span> <span class='op'>+</span> <span class='int'>1</span>
    <span class='comment'># Write a record only on the last record record in the group
</span>    <span class='id identifier rubyid_ds_out'>ds_out</span><span class='period'>.</span><span class='id identifier rubyid_write_record'>write_record</span> <span class='kw'>if</span> <span class='id identifier rubyid_ds_in'>ds_in</span><span class='period'>.</span><span class='id identifier rubyid_last'>last</span><span class='lparen'>(</span><span class='symbol'>:var1</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h3>Aggregating</h3>

<p>The example above shows how by-groups can be used to aggregate data.
By-groups are very useful in many other situations, but are a little
cumbersome for simple aggregation (especially if we don&#39;t want to go
through the trouble of sorting a dataset).  Therefore, we plan on
developing a simple aggregator syntax.</p>

<h6>Proposed</h6>

<pre class="code ruby"><code class="ruby"><span class='comment'># We&#39;ll want an aggregator class that specific aggregation classes inherit
</span>
<span class='comment'># Want the aggregator class to allow something like these functions:
</span>
<span class='comment'># Define a function that will sum the squares of a value
</span><span class='kw'>class</span> <span class='const'>SumSquare</span> <span class='op'>&lt;</span> <span class='const'>Aggregator</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_record'>record</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span>
    <span class='ivar'>@result</span> <span class='op'>+=</span> <span class='id identifier rubyid_value'>value</span><span class='op'>**</span><span class='int'>2</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># Define a mean function
</span><span class='kw'>class</span> <span class='const'>Mean</span> <span class='op'>&lt;</span> <span class='const'>Aggregator</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_begin_group'>begin_group</span>
    <span class='ivar'>@mean_sum</span> <span class='op'>=</span> <span class='int'>0</span>
    <span class='ivar'>@n</span> <span class='op'>=</span> <span class='int'>0</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_record'>record</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span>
    <span class='ivar'>@mean_sum</span> <span class='op'>+=</span> <span class='id identifier rubyid_value'>value</span>
    <span class='ivar'>@n</span> <span class='op'>+=</span> <span class='int'>1</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_end_group'>end_group</span>
    <span class='ivar'>@result</span> <span class='op'>=</span> <span class='ivar'>@mean_sum</span> <span class='op'>/</span> <span class='ivar'>@n</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># Run the aggregate datastep
</span><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_aggregate'>aggregate</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_have'>have</span><span class='comma'>,</span> <span class='label'>out:</span><span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_aggregated'>aggregated</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_a'>a</span><span class='op'>|</span>
  <span class='comment'># indicate that source data is not necessarily sorted (results must fit into memory)
</span>  <span class='id identifier rubyid_a'>a</span><span class='period'>.</span><span class='id identifier rubyid_sorted'>sorted</span> <span class='kw'>false</span>
  <span class='comment'># Define grouping variables
</span>  <span class='id identifier rubyid_a'>a</span><span class='period'>.</span><span class='id identifier rubyid_by'>by</span> <span class='symbol'>:var1</span>
  <span class='comment'># Define aggregation functions
</span>  <span class='id identifier rubyid_a'>a</span><span class='period'>.</span><span class='id identifier rubyid_functions'>functions</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span>
    <span class='comment'># :amount is a variables in the mylib.have dataset
</span>    <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='symbol'>:amount_sum_of_square</span><span class='comma'>,</span> <span class='symbol'>:amount</span><span class='comma'>,</span> <span class='symbol'>:SumSqaure</span>
    <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='symbol'>:amount_mean</span><span class='comma'>,</span> <span class='symbol'>:amount</span><span class='comma'>,</span> <span class='symbol'>:Mean</span>
  <span class='kw'>end</span>
  <span class='comment'># Dataset is output at the end of the block
</span><span class='kw'>end</span>
</code></pre>

<p>It would be really cool if we could build aggregator functions that could play
off of each other.  For example, calculated standard errors requires summing
the square of the difference between an individual record and the group mean.
It would be great if we could define an interface to make that kind of this simple</p>

<h3>Merging</h3>

<h6>Proposed</h6>

<pre class="code ruby"><code class="ruby"><span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_merged'>merged</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds_out'>ds_out</span><span class='op'>|</span>
  <span class='const'>Variables</span><span class='period'>.</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_ds_out'>ds_out</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_left'>ds_left</span>
    <span class='id identifier rubyid_v'>v</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_right'>ds_right</span>
  <span class='kw'>end</span>

  <span class='comment'># Merge assumes ds_left and ds_right are sorted by the by variables
</span>  <span class='const'>Datastep</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_left'>ds_left</span><span class='comma'>,</span> <span class='id identifier rubyid_mylib'>mylib</span><span class='period'>.</span><span class='id identifier rubyid_ds_right'>ds_right</span><span class='comma'>,</span> <span class='label'>by:</span> <span class='lbracket'>[</span><span class='symbol'>:var1</span><span class='comma'>,</span> <span class='symbol'>:var2</span><span class='rbracket'>]</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ds_merge'>ds_merge</span><span class='op'>|</span>
    <span class='id identifier rubyid_ds_out'>ds_out</span><span class='period'>.</span><span class='id identifier rubyid_read_row_from'>read_row_from</span> <span class='id identifier rubyid_ds_merge'>ds_merge</span>
    <span class='comment'># Perform a left join by selecting all records in the left dataset
</span>    <span class='id identifier rubyid_ds_out'>ds_out</span><span class='period'>.</span><span class='id identifier rubyid_write_record'>write_record</span> <span class='kw'>if</span> <span class='id identifier rubyid_ds_merge'>ds_merge</span><span class='period'>.</span><span class='id identifier rubyid_in'>in</span><span class='lparen'>(</span><span class='symbol'>:ds_left</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>The above would be a way to easily perform inner, left, and right
joins.  I&#39;m not sure at this point whether I want to support full
outer joins, because there might be complex memory issues.  On the
other hand many-to-many merges in SAS are pretty much worthless, so it
might be good to support a genuine many-to-many merge.  So we might
have to figure out a good way to get around the memory issue, or maybe
even ONLY support full outer joins that fit into memory (error if the
outer join is too big).</p>

<h3>Business Rules</h3>

<h6>Proposed</h6>

<p>I&#39;m still very fuzzy on the structure of the business rule definitions
and tests.  I&#39;m not sure whether this can be just an extension of
Rspec, or if it needs to be a completely new system.  I&#39;m expecting
something that may roughly look like this (this psuedocode needs a lot
of work)</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># The rule definition that gets applied when the ETL runs
</span><span class='id identifier rubyid_define'>define</span> <span class='id identifier rubyid_rule'>rule</span> <span class='symbol'>:category_map</span><span class='comma'>,</span> <span class='label'>args:</span> <span class='lbracket'>[</span><span class='symbol'>:data_record</span><span class='comma'>,</span> <span class='symbol'>:category_map</span><span class='rbracket'>]</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_describe'>describe</span> <span class='id identifier rubyid_rule'>rule</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Use the category map to add descriptions to the category keys</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span> <span class='comment'># Required examples
</span>    <span class='id identifier rubyid_input_record'>input_record</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>A</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span><span class='int'>50</span><span class='rbracket'>]</span>
    <span class='id identifier rubyid_category_map'>category_map</span> <span class='op'>=</span> <span class='lbrace'>{</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>A</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Category Alpha</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_expected_output_record'>expected_output_record</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Category Alpha</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span><span class='int'>50</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>

    <span class='comment'>#... code that does the mapping ...
</span><span class='kw'>end</span>

<span class='comment'># A test that the rule definition gives the expected result
</span><span class='id identifier rubyid_expect'>expect</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_apply_rule'>apply_rule</span><span class='lparen'>(</span><span class='symbol'>:category_map</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_input_record'>input_record</span><span class='comma'>,</span> <span class='id identifier rubyid_category_map'>category_map</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_eq'>eq</span> <span class='id identifier rubyid_expected_output_record'>expected_output_record</span>
</code></pre>

<h2>Contributing</h2>

<p>The best way to contribute would be to try it out and provide as much
feedback as possible.</p>

<p>If you want to develop the Remi framework then just fork, code, pull
request, repeat.  Try to follow the
<a href="https://github.com/styleguide/ruby">Ruby style guide</a> and suggest
other best practices.  I&#39;m very interested in getting other ETL
developers contribute their own perspective to the project.</p>

<h2>About</h2>

<p>Remi was conceived during the paternity time I took off work to care
for my son during his first week of life, whose name is not
coincidentally also Remi.  While I suppose a better father would have
had nothing to do other than dote and oogle over their new baby, the
fact of the matter is that newborns are just plain boring.  Other than
making sure they&#39;re snuggled and their mothers get enough sleep,
there&#39;s not much to do but stare and them and think.  So I found
myself daydreaming a lot about my job and what I can do to fix my
least favorite parts of it.</p>

<p>I started doing ETL work about five years prior to Remi when I worked
in the analytics unit of a health insurance company.  We used a
dinosaur of a language called SAS to transform claim data into
business-reportable cubes.  Despite it being a language that was
clearly showing its age, it was still fairly expressive and
facilitated writing fast and complex ETL code.  I ended up getting
pretty good at SAS, and the warehouse I helped build supported the
company&#39;s core analytics efforts.  But then I got fed up with the
bureaucracy, politics, and apathy of working for large old fashioned
company and decided to join a startup that prided themselves on
cloud-based open source technology.</p>

<p>At first I felt very lost without SAS, but with the cost of a license
being roughly $5,000/year, all of my SAS-specific knowledge was pretty
worthless.  It was hard to find alternative open source tools that
made it quick and easy to visualize data for the purposes of data
transformation and integration.  Sure, there&#39;s R, but while learning
it, I very quickly started running into the memory limits and the
community packages to work around the issue felt very cumbersome.</p>

<p>My new company had chosen to go with Pentaho&#39;s Kettle for their ETL
solution.  At first, I rather liked it.  It was nice to see data
transformations laid out visually, and it was a snap to bring in new
data sources.  Of course, the problem with GUI-based programming is
that if the developers didn&#39;t think of including something in the
package, you&#39;re pretty much SOL.  It&#39;s also next-to-impossible to
design modular, test-driven, and flexible ETL using Kettle (if you
disagree, I&#39;d love to see examples).  Despite our best efforts, our
Kettle code base became very difficult to manage due to a large amount
of mostly-but-not-quite-duplicated code.  Transformations would
frequently break when we fixed some seemingly-unrelated bugs.  Not to
mention the fact that the transformations we built would quickly drift
away from any business rules documentation, assuming they even
existed.</p>

<p>I wanted an ETL system that offered the expressiveness of a procedural
ETL solution like SAS, but also facilitated more modern coding
standards and conventions.  I had recently been exposed to Ruby
through some DevOps Chef projects and just though it would be great
fun to build a significant project with it.  So, I started building
out the core functionality of Remi during those first few weeks of
staying up late with Remi crying and sleeping in 15 minute sprints.</p>
</div></div>

    <div id="footer">
  Generated on Mon May 26 12:30:25 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.4 (ruby-2.0.0).
</div>

  </body>
</html>